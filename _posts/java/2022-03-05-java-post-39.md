---
title: "클린코드 (5) 오류처리"
date: 2022-03-05-00:00:00 -0000
categories: JAVA

---

우아하게 예외 처리 하기 


## 목차
1. 예외 처리 방식
2. Uncheked Exception
3. Exception 잘 쓰기
4. 실무 예외 처리 패턴
5. 오픈소스 속 Exception 살펴보기 

## 예외 처리 방식

__오류 코드를 리턴하지 말고 예외를 던져라__
- 옛날에는 오류를 나타낼 떄 에러 코드를 던졌다.
- 하지만 예외를 던지는 것이 훨신 명확하고, 처리 흐름이 깔끔해진다.



```java
// 잘못된 방법 : 오류 플래그를 설정하거나 호출자에게 오류 코드를 변환하는 방법

public class DeviceController {

	...

	DeviceHandle handle = getHandle(DEV1);
	if (handle != DeviceHandle.INVALID) {
		retrieveDeviceRecord(handle);
		if (record.getStatus() != DEVICE_SUSPENDED) {
			closeDevice(handle);
		} else {
			logger.log("Device suspended. Unable to shut down");
		}
	} else {
		logger.log("Invalid handle");
	}

	...
}
```

위 코드의 문제: __호출 코드가 복잡해 진다. 함수를 호출한 즉시 오류를 확인해야 하기 떄문__

```java
// 현재의 예외처리 방식 코드 
public class DeviceController {
    ...

    //3
    public void sendShutDown() {
        try {
            tryToShutDown();

        } catch (DeviceShutDownError e) {
            logger.log(e);
        }
    }
    
    //2
    private void tryToShutDown() throws DeviceShutDownError() {
        DeviceHandle handle = getHandle(DEV1);
        DeviceRecord record = retrieveDeviceRecord(handle);
        pauseDevice(handle);
        clearDeviceWordQueue(handle);
        closeDevice(handle);
    }

    // 1
    private DeviceHandle getHandle(DeviceID id) {
        ...
        throw new DeviceShutDownError("blah blah");
        ...
    }
}
```

1. 오류가 발생한 부분에서 예외를 던진다. (별도의 처리가 필요한 예외라면 checked exception으로 던진다.)
2. checked exception 에 대한 예외 처리를 하지 않는 다면 메서드 선언부에서 throws를 명시해야한다.
3. 예외를 처리할 수 있는 곳에서 catch하여 처리한다.


#### Exception 가계도

![익셉션](https://media.vlpt.us/images/doforme/post/ef304ae5-17d9-42ed-aa3b-2ae1e8ee8965/image.png?w=768)

#### Checked vs Unchecked Exception

- Checked Exception
    - __Exception__을 상속하면 __Checked Exception__ 명시적인 예외처리가 필요함.
        - 예 IOException, SQLException
    - 확인시점 : 컴파일 시점
    - 처리 여부 : 반드시 처리
    - 트랜잭션 처리 : roll-back 하지 않음 
    

- __RuntimeException__을 상속하면 __UncheckedException__ 명시적인 예외처리가 필요하지 않는다.
    - NullPointerException, IlleegalArgumentException, IndexOutOfBoundException 
    - 확인시점 : 런타임 시점
    - 처리 여부 : 명시적으로 처리하지 않아도 됨
    - roll-back 함



#### Effective Java, Exception에 대한 규약
```
자바 언어 명세가 요구하는 것은 아니지만, 업계에 널리 펴진 규약으로 
__Error__ 클래스를 상속해 하위 클래스를 만드는 일을 자재하자.

즉, 사용자가 직접 구현하는 unchecked throwable은 모두 RuntieException의 하위 클래스여야 한다.

Exception, RuntimeException, Erro를 상속하지 않는 throwable 을 만들수도 있지만, 이러한 throwable은 정상적인 사항보다 나을게 없으며, api 사용자를 헷갈리게 할 뿐이다.
```


#### Checked Excpetiond이 나쁜이유

이전 코드를 보자
```java
public class DeviceController {
    ...

    //3
    public void sendShutDown() {
        try {
            tryToShutDown();

        } catch (DeviceShutDownError e) {
            logger.log(e);
        }
    }
    
    // 2
    // 여기서는 하나지만 2, 3, +++ depth 가 된다면 throws DeviceShutDownError 을 계속 던져줘야함 
    private void tryToShutDown() throws DeviceShutDownError {
        DeviceHandle handle = getHandle(DEV1);
        DeviceRecord record = retrieveDeviceRecord(handle);
        pauseDevice(handle);
        clearDeviceWordQueue(handle);
        closeDevice(handle);
    }

    // 1
    private DeviceHandle getHandle(DeviceID id) {
        ...
        throw new DeviceShutDownError("blah blah");
        ...
    }
}
```

1. 특정 메소드에서 checked Exception을 throw 하고 상위 메소드에서 그 exception을 catch한다면 모든 중간단계 메소드에 excpetion을 trows 해야 한다.
2. OCP (패쇄 개방 원칙) 위배
    상위 레벨 메서드에서 하위 레벨 메서드의 디테일에 대해 알아야 하기 떄문에 OCP 원칙을 위배한다.
3. 필요한 경우 checked exception을 사용해야 되지만 일반적인 경우 득보다 실이 많다. 


## Unchecked Exception 를 사용하라,
```
Checked Exception은 선언부의 수정을 필요로 하기 떄문에 모듈의 캡슐화를 꺠버린다. 
```

안정적인 소프트웨어를 제작하는 요소로 확인된 예외가 반드시 필요하지 않다는 사실이 분병해졌다.




## Exception 잘 쓰기
- 예외에 메세지 담기 
    - 오류가 발생한 위치를 찾기 쉽도록, 예외를 던질 떄는 전후 상황을 충분히 덧붙인다.
    - 실패한 연산과 이름과 유형 등 정보를 담아 예외를 던진다. 


#### 예외를 감싸는 클래스를 만들자.


## 실무 예외 처리 패턴

#### getOrElse vs getOrElseThrows
- getOrElse
    - 예외 대신 기본 값을 리턴한다.
    - null이 아닌 기본 값.
    - 도메인에 맞는 기본값

- getOrElseThrow 
    - null 대신 예외를 던진다. (기본 값이 없다면)

#### getOrElse - 예외 대신 기본값을 리턴

__bad__
```java
// 잘못된 예시
List<Employee> employees = getEmployees();
if (employees != null) {
    for (Employee e : employees) {
        totalPay += e.getPay();
    }
}

// getEmployees를 설계할 때, 데이터가 없는 경우를 null 로 표현했는데, 다른 방법은 없을까?. 
// null 을 리턴한다면 이후 코드에서 모두 null 체크가 되어야 한다.
```

__good__
```java
// null이 아닌 기본값을 리턴한다.

List<Employee> employees = getEmployees();
for (Employee e : employees) {
    totalPay += e.getPay();
}


public List<Employee> getEmployees() {
    if (..no employees ..) {
        return Collections.emptyList();
    }
}
```