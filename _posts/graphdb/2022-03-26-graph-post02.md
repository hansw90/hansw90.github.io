---
title: "GraphDB (1) 그래프 이론"
date: 2022-03-26 15:11:00 -0000 
categories: graph

---

오전 8시까지 밤샘 일을 하고 오니,,,, (블로그 쓰기가 너무 힘들어ㅓ,,,,,,,,)

오늘 한국어 그래프디비 구축 첫 회의가 있는날 이란걸 깨달았다..

아,,, 도착한지 3시간밖에 못잤는데,, 부랴부랴 들어가서 회의에 참석하고 간단 내용을 공유했다.

오늘은 간단히 소개와 기존에 제공되던 데이터들을 확인하는 자리였다. 

그리고 이번주 미션은 그래프 이론에 대해 다시 알아오기, 학교다닐때 잠시 배우기도 했지만,, 아직 잘 모르는 ㅠ

그래서 오늘은 숙제겸 그래프이론을 다시금 공부해 보려한다,


--------------

## 목차
1. 개요
2. 그래프 관련 용어
3. 그래프 종류
4. 그래프 알고리즘
   1. 인접 리스트
   2. 인접 행렬
5. 그래프 탐색
   1. 깊이 우선 탐색 DFS
   2. 너비 우선 탐색 BFS
6. 코드로 보는 그래프 (python)

-----

## 1. 개요
```
그래프 이론은 수학에서 객체 간의 짝을 이루는 관계를 모델링 하기위해 사용되는 수학 구조인 그래프에 대한 연구이다. 이 문맥에서 그래프는 꼭지점(vertex), 교점(node), 점(point) 으로 구성 되며 이것들을 변(엣지/EDGE/간선) 즉 선으로 연결한다. 그래프는 무향(무방향성) 일수 있는데 이는 각 변(엣지)로 연결되는 두개의 꼭지점 간에 구별이 없다는 의미이며, 한편 변은 한 꼭지점에서 다른 꼭지점에서 다른 꼭짓점 간에 방향이 있을수도 있다. 
```
가장 일반적으로는 그래프는 순서쌍 G=(V, E)로 볼 수 있다. 여기에서 집합 V는 꼭지점 E는 간선을 의미한다. 혼동을 피하기 위해 이러한 형태의 그래프는 정확히 방향이 없는 단순한 그래프라고 기술할 수 있다.

## 2. 그래프 관련 용어
- __정점__: vertex 위치 개념 (노드)
- __간선__: edge 위치간의 관계, 즉 노드를 연결하는 선(link, branch라고도 부른다)
- __인접 정접__: adjacent vertex, 간선에 의해 직접 연결된 정점
- __정접의 차수__: degree, 무방향 그래프에서 하나의 정점에 인접한 정점의 수 
  - 무방향 그래프에 존재하는 정점의 모든 차수의 합 = 그래프 간선 수의 2배
- __진입 차수__: 방향 그래프에서 외부에서 오는 간선의 수 (내차수)
- __진출 차수__: 방향 그래프에서 외부로 향하는 간선의 수 (외차수)
- __경로 길이__: path length, 경로를 구성하는 데 사용된 간선의 수
- __단순 경로__: simple path, 경로 중에서 반복되는 정접이 없는 경우
- __사이클__: 단순 경로의 시작 정점과 종료 정점이 동일한 경우 

## 3. 그래프의 종류
- 그래프의 각 변에 방향을 추가하면, __유향 그래프__를 얻는다.
- 그래프의 각 변에 중복수를 추가하면 __다중 그래프__가 된다
- 그래프의 각 변에 +- 부호를 추가하면 __부호형 그래프__를 얻는다.
- 그래프의 각 꼭짓점에 색을 추가하면, 그래프 색칠을 얻는다.

그래프들은 또한 각종 구조들을 갖는다.
- 경로: 같은 꼭짓점을 거듭 거치치 않는 변들의 열
- 순환: 순환은 그래프 위의 스스로와 겹치지 않는 폐곡선(회로)라고 한다.
- 부분 그래프: 어떤 그래프의 꼭짓점과 변 가운데 일부로 이루어진 그래프이다.
- 연결 그래프: 
  - ![](https://upload.wikimedia.org/wikipedia/commons/thumb/0/08/Teilgraphenbeziehungen.svg/900px-Teilgraphenbeziehungen.svg.png)
  - 위 그림에서 g1,g2,g3 는 모두 G의 부분 그래프이다.
- 마이너: 어떤 그래프의 변들을 축약시켜 얻은 그래프.
- 클릭: 모든 가능한 변이 존재하는 꼭짓점들의 부분 집합.

이러한 구조들을 통해 그래프들을 분류할 수 있다.
- 순환그래프
  - 순환그래프는 정다각형의 그래프 
  - ![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/f6/Undirected_6_cycle.svg/330px-Undirected_6_cycle.svg.png)


- 완전그래프
  - 완전 그래프는 서로 다른 두개의 꼭짓점이 반드시 하나의 변으로 연결된 그래프이다.

- 정규그래프
  - 정규 그래프는 모든 꼭짓점이 동일한 수의 이웃을 가지는 그래프이다. 모든 꼭짓점이 모두 같은 __차수__를 가진다.
  - ![](https://upload.wikimedia.org/wikipedia/commons/thumb/4/48/Petersen_graph_blue.svg/330px-Petersen_graph_blue.svg.png)

- 트리
  - 나무 그래프
  - 트리는 순환을 갖지 않는 연결 그래프이다.
  - ![](https://gmlwjd9405.github.io/images/data-structure-graph/graph-vs-tree.png)

- 완벽그래프 
  - 완벽 그래프는 그 색칠수가 클릭과 특별한 관계를 만족 시키는 그래프이다.
- 이분그래프
  - 이분 그래프란 모든 꼭짓점을 빨강과 파랑으로 색칠하되, 모든 변이 빨강과 파랑 꼭짓점을 포함하도록 색칠할 수 있는 그래프
- 평면그래프
  - 평면상에 그래프를 그렸을떄, 두변이 꼭짓점 이외에 만나지 않도록 그릴수 있는 그래프
- 삼차그래프 (정규 그래프)
  - 모든 꼭짓점이 동일한 수의 이웃을 가지느 그래프, 즉 모든 꼭짓점이 같은 차수를 가진다. (페테르센 그래프, 완전 이분 그래프)


## 4. 그래프 알고리즘 (자료구조)
컴퓨터 시스템에서 그래프를 저장하는 방법은 여러가지가 있다. 
이론적으로 그래프는 리스트와 행렬 구조중의 하나로 구별이 가능하다. 하지만 실제 적용에 있어서 최적의 자료구조는 이 두 구조의 조합된 형태를 띤다. 
리스트 구조는 sparse graph에 적합하며, 적은 메모리 공간을 요구한다.
행렬 구조는 많은 양의 메모리를 필요로 하지만 더욱 빠른 접근을 제공한다.

### 4-1. 인접 리스트(Adjacency List)
### 4-2. 인접 행렬(Adjacency Matrix)

그래프 G=(V, E)를 n>=1 의 정점의 가진 그래프라고 할떄 그래프 G에 대한 인접행렬의 크기는 n*n이며 a[n, n] 크기의 2차원 배열로 표현된다.
이때 a[n, n] 에서 a[i, j] ∈ E(G) 라면 1 아니라면 0의 값을 가진다.

인접행렬의 표현방식에서 진입 차수와 진출차수는 a[i, j] ∈ E(G)의 경우에 i 행의 합을 구하면 진출 차수이고 i 열의 합을 구하면 진입 차수이다.


```java
public class GraphAjdacencyMatrix {
    int vertex;
    int matrix[][];

    public GraphAjdacencyMatrix(int vertex) {
        this.vertex = vertex;
        matrix = new int[vertex][vertex];
    }

    public void addEdge(int source, int destination) {
        //add edge
        matrix[source][destination]=1;

        //add bak edge for undirected graph
        matrix[destination][source] = 1;
    }

    public void printGraph() {
        System.out.println("Graph: (Adjacency Matrix)");
        for (int i = 0; i < vertex; i++) {
            for (int j = 0; j <vertex ; j++) {
                System.out.print(matrix[i][j]+ " ");
            }
            System.out.println();
        }
        for (int i = 0; i < vertex; i++) {
            System.out.print("Vertex " + i + " is connected to:");
            for (int j = 0; j <vertex ; j++) {
                if(matrix[i][j]==1){
                    System.out.print(j + " ");
                }
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        GraphAjdacencyMatrix graph = new GraphAjdacencyMatrix(5);
        graph.addEdge(0, 1);
        graph.addEdge(0, 4);
        graph.addEdge(1, 2);
        graph.addEdge(1, 3);
        graph.addEdge(1, 4);
        graph.addEdge(2, 3);
        graph.addEdge(3, 4);
        graph.printGraph();
    }
}
```

## 5. 그래프 탐색

### 5-1 DFS 깊이 우선 탐색

깊이 우선탐색에서 단순 트리의 깊이 우선탐색과 그래프의 깊이우선탐색은 조금 다르다. 
이걸 알고 두가지가 어떻게 다른지 알아보도록 하자

- 깊이우선탐색 (Depth first search)
- 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘
- 보통 스택, 재귀를 활용한다.
- 동작 과정
  1. 탐색 시작 노드를 스택에 삽입하고 방문처리 한다.
  2. 스택의 최상단 노드에 방문하지 않은 인접한 노드가 있으면 그 노드를 스택에 넣고 방문 처리를 한다.
    방문하지 않는 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.
  3. 2번의 과정을 수행할수 없을 떄까지 반복한다.
  


참조
https://namu.wiki/w/%EA%B7%B8%EB%9E%98%ED%94%84(%EC%9D%B4%EC%82%B0%EC%88%98%ED%95%99)
https://datascienceschool.net/03%20machine%20learning/17.01%20%EA%B7%B8%EB%9E%98%ED%94%84%20%EC%9D%B4%EB%A1%A0%20%EA%B8%B0%EC%B4%88.html
https://gmlwjd9405.github.io/2018/08/13/data-structure-graph.html
https://kingpodo.tistory.com/46