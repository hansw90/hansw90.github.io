---
title: "GraphDB (1) 그래프 이론"
date: 2022-03-26 15:11:00 -0000 
categories: graph

---

오전 8시까지 밤샘 일을 하고 오니,,,, (블로그 쓰기가 너무 힘들어ㅓ,,,,,,,,)

오늘 한국어 그래프디비 구축 첫 회의가 있는날 이란걸 깨달았다..

아,,, 도착한지 3시간밖에 못잤는데,, 부랴부랴 들어가서 회의에 참석하고 간단 내용을 공유했다.

오늘은 간단히 소개와 기존에 제공되던 데이터들을 확인하는 자리였다. 

그리고 이번주 미션은 그래프 이론에 대해 다시 알아오기, 학교다닐때 잠시 배우기도 했지만,, 아직 잘 모르는 ㅠ

그래서 오늘은 숙제겸 그래프이론을 다시금 공부해 보려한다,


--------------

## 목차
1. 개요
2. 그래프 관련 용어
3. 그래프 종류
4. 그래프 알고리즘
   1. 인접 리스트
   2. 인접 행렬
5. 그래프 탐색
   1. 깊이 우선 탐색
   2. 너비 우선 탐색
6. 코드로 보는 그래프 (python)

-----

## 1. 개요
```
그래프 이론은 수학에서 객체 간의 짝을 이루는 관계를 모델링 하기위해 사용되는 수학 구조인 그래프에 대한 연구이다. 이 문맥에서 그래프는 꼭지점(vertex), 교점(node), 점(point) 으로 구성 되며 이것들을 변(엣지/EDGE/간선) 즉 선으로 연결한다. 그래프는 무향(무방향성) 일수 있는데 이는 각 변(엣지)로 연결되는 두개의 꼭지점 간에 구별이 없다는 의미이며, 한편 변은 한 꼭지점에서 다른 꼭지점에서 다른 꼭짓점 간에 방향이 있을수도 있다. 
```
가장 일반적으로는 그래프는 순서쌍 G=(V, E)로 볼 수 있다. 여기에서 집합 V는 꼭지점 E는 간선을 의미한다. 혼동을 피하기 위해 이러한 형태의 그래프는 정확히 방향이 없는 단순한 그래프라고 기술할 수 있다.

## 2. 그래프 관련 용어
- __정점__: vertex 위치 개념 (노드)
- __간선__: edge 위치간의 관계, 즉 노드를 연결하는 선(link, branch라고도 부른다)
- __인접 정접__: adjacent vertex, 간선에 의해 직접 연결된 정점
- __정접의 차수__: degree, 무방향 그래프에서 하나의 정점에 인접한 정점의 수 
  - 무방향 그래프에 존재하는 정점의 모든 차수의 합 = 그래프 간선 수의 2배
- __진입 차수__: 방향 그래프에서 외부에서 오는 간선의 수 (내차수)
- __진출 차수__: 방향 그래프에서 외부로 향하는 간선의 수 (외차수)
- __경로 길이__: path length, 경로를 구성하는 데 사용된 간선의 수
- __단순 경로__: simple path, 경로 중에서 반복되는 정접이 없는 경우
- __사이클__: 단순 경로의 시작 정점과 종료 정점이 동일한 경우 

## 3. 그래프의 종류
- 그래프의 각 변에 방향을 추가하면, __유향 그래프__를 얻는다.
- 그래프의 각 변에 중복수를 추가하면 __다중 그래프__가 된다
- 그래프의 각 변에 +- 부호를 추가하면 __부호형 그래프__를 얻는다.
- 그래프의 각 꼭짓점에 색을 추가하면, 그래프 색칠을 얻는다.

그래프들은 또한 각종 구조들을 갖는다.
- 경로: 같은 꼭짓점을 거듭 거치치 않는 변들의 열
- 순환: 순환은 그래프 위의 스스로와 겹치지 않는 폐곡선(회로)라고 한다.
- 부분 그래프: 어떤 그래프의 꼭짓점과 변 가운데 일부로 이루어진 그래프이다.
- 연결 그래프: 
  - ![](https://upload.wikimedia.org/wikipedia/commons/thumb/0/08/Teilgraphenbeziehungen.svg/900px-Teilgraphenbeziehungen.svg.png)
  - 위 그림에서 g1,g2,g3 는 모두 G의 부분 그래프이다.
- 마이너: 어떤 그래프의 변들을 축약시켜 얻은 그래프.
- 클릭: 모든 가능한 변이 존재하는 꼭짓점들의 부분 집합.

이러한 구조들을 통해 그래프들을 분류할 수 있다.
- 순환그래프
  - 순환그래프는 정다각형의 그래프 
  - ![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/f6/Undirected_6_cycle.svg/330px-Undirected_6_cycle.svg.png)


- 완전그래프
  - 완전 그래프는 서로 다른 두개의 꼭짓점이 반드시 하나의 변으로 연결된 그래프이다.

- 정규그래프
  - 정규 그래프는 모든 꼭짓점이 동일한 수의 이웃을 가지는 그래프이다. 모든 꼭짓점이 모두 같은 __차수__를 가진다.
  - ![](https://upload.wikimedia.org/wikipedia/commons/thumb/4/48/Petersen_graph_blue.svg/330px-Petersen_graph_blue.svg.png)

- 트리
  - 나무 그래프
  - 트리는 순환을 갖지 않는 연결 그래프이다.
  - ![](https://gmlwjd9405.github.io/images/data-structure-graph/graph-vs-tree.png)

- 완벽그래프 
  - 완벽 그래프는 그 색칠수가 클릭과 특별한 관계를 만족 시키는 그래프이다.
- 이분그래프
  - 이분 그래프란 모든 꼭짓점을 빨강과 파랑으로 색칠하되, 모든 변이 빨강과 파랑 꼭짓점을 포함하도록 색칠할 수 있는 그래프
- 평면그래프
  - 평면상에 그래프를 그렸을떄, 두변이 꼭짓점 이외에 만나지 않도록 그릴수 있는 그래프
- 삼차그래프 (정규 그래프)
  - 모든 꼭짓점이 동일한 수의 이웃을 가지느 그래프, 즉 모든 꼭짓점이 같은 차수를 가진다. (페테르센 그래프, 완전 이분 그래프)


## 4. 그래프 알고리즘 (자료구조)
컴퓨터 시스템에서 그래프를 저장하는 방법은 여러가지가 있다. 
이론적으로 그래프는 리스트와 행렬 구조중의 하나로 구별이 가능하다. 하지만 실제 적용에 있어서 최적의 자료구조는 이 두 구조의 조합된 형태를 띤다. 
리스트 구조는 sparse graph에 적합하며, 적은 메모리 공간을 요구한다.
행렬 구조는 많은 양의 메모리를 필요로 하지만 더욱 빠른 접근을 제공한다.

### 4-1. 인접 리스트(Adjacency List)

인접 리스트로 그래프를 표현하는 것이 일반적인 방법
- 모든 정점(노드)를 인접 리스트에 저장한다. 즉, 각각의 정점에 인접한 정점들을 리스트로 표시한 것
  - 배열 (혹은 해시테이블)과 배열의 각 인덱스마다 존재하는 또 다른 리스트 를 이용하여 인접 리스트를 표현한다.
  - 정점의 번호만 알면 이 번호를 배열의 인덱스로 하여각 정점의 리스트에 쉽게 접근이 가능하다.
- 무방향 그래프에서 (a, b) 간선은 두 번 저장된다.
  - 한 번은 a정점에 인접한 간선을 저장하고 다른 한 번은 b에 인접한 간선을 저장한다.
  - 정점의 수: N 간선의 수: E인 무뱡향 그래프
    - N개의 리스트, N개의 배열, 2E개의 노드가 필요
- 트리에선 특정 노드 하나 (루트 노드)에서 다른 모든 노드로 접근이 가능 -> Tree 클래스 불필요
  - 그래프에선 특정 노드에서 다른 모든 노드로 접근이 가능한게 아님 -> Graph 클래스 필요

```java
import java.util.LinkedList;

public class Graph {
    int vertex;
    LinkedList<Integer> list[];

    public Graph(int vertex) {
        this.vertex = vertex;
        list = new LinkedList[vertex];
        for (int i = 0; i <vertex ; i++) {
            list[i] = new LinkedList<>();
        }
    }

    public void addEdge(int source, int destination){

        //add edge
        list[source].addFirst(destination);

        //add back edge ((for undirected)
        list[destination].addFirst(source);
    }

    public void printGraph(){
        for (int i = 0; i <vertex ; i++) {
            if(list[i].size()>0) {
                System.out.print("Vertex " + i + " is connected to: ");
                for (int j = 0; j < list[i].size(); j++) {
                    System.out.print(list[i].get(j) + " ");
                }
                System.out.println();
            }
        }
    }

    public static void main(String[] args) {
        Graph graph = new Graph(5);
        graph.addEdge(0, 1);
        graph.addEdge(0, 4);
        graph.addEdge(1, 2);
        graph.addEdge(1, 3);
        graph.addEdge(1, 4);
        graph.addEdge(2, 3);
        graph.addEdge(3, 4);
        graph.printGraph();
    }
}
```

### 4-2. 인접 행렬(Adjacency Matrix)


참조
https://namu.wiki/w/%EA%B7%B8%EB%9E%98%ED%94%84(%EC%9D%B4%EC%82%B0%EC%88%98%ED%95%99)
https://datascienceschool.net/03%20machine%20learning/17.01%20%EA%B7%B8%EB%9E%98%ED%94%84%20%EC%9D%B4%EB%A1%A0%20%EA%B8%B0%EC%B4%88.html
https://gmlwjd9405.github.io/2018/08/13/data-structure-graph.html